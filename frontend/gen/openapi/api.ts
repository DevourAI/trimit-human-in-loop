/* tslint:disable */
/* eslint-disable */
/**
 * TrimIt API
 * API documentation
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CutTranscriptLinearWorkflowStepInput
 */
export interface CutTranscriptLinearWorkflowStepInput {
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepInput
     */
    'user_prompt'?: string | null;
    /**
     * 
     * @type {PartialFeedback}
     * @memberof CutTranscriptLinearWorkflowStepInput
     */
    'llm_modified_partial_feedback'?: PartialFeedback | null;
    /**
     * 
     * @type {boolean}
     * @memberof CutTranscriptLinearWorkflowStepInput
     */
    'is_retry'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepInput
     */
    'step_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepInput
     */
    'substep_name'?: string | null;
}
/**
 * 
 * @export
 * @interface CutTranscriptLinearWorkflowStepOutput
 */
export interface CutTranscriptLinearWorkflowStepOutput {
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'step_name': string;
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'substep_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'done'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'user_feedback_request'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'partial_user_feedback_request'?: string | null;
    /**
     * 
     * @type {CutTranscriptLinearWorkflowStepInput}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'step_inputs'?: CutTranscriptLinearWorkflowStepInput | null;
    /**
     * 
     * @type {object}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'step_outputs'?: object | null;
    /**
     * 
     * @type {{ [key: string]: CutTranscriptLinearWorkflowStepOutputExportResultValue; }}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'export_result'?: { [key: string]: CutTranscriptLinearWorkflowStepOutputExportResultValue; } | null;
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'export_call_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'error'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CutTranscriptLinearWorkflowStepOutput
     */
    'retry'?: boolean;
}
/**
 * 
 * @export
 * @interface CutTranscriptLinearWorkflowStepOutputExportResultValue
 */
export interface CutTranscriptLinearWorkflowStepOutputExportResultValue {
}
/**
 * 
 * @export
 * @interface GetStepOutputs
 */
export interface GetStepOutputs {
    /**
     * 
     * @type {Array<CutTranscriptLinearWorkflowStepOutput>}
     * @memberof GetStepOutputs
     */
    'outputs': Array<CutTranscriptLinearWorkflowStepOutput>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface PartialFeedback
 */
export interface PartialFeedback {
    /**
     * 
     * @type {Array<boolean>}
     * @memberof PartialFeedback
     */
    'partials_to_redo': Array<boolean>;
    /**
     * 
     * @type {RelevantUserFeedbackList}
     * @memberof PartialFeedback
     */
    'relevant_user_feedback_list': RelevantUserFeedbackList;
}
/**
 * 
 * @export
 * @interface RelevantUserFeedbackList
 */
export interface RelevantUserFeedbackList {
}
/**
 * 
 * @export
 * @interface RelevantUserFeedbackListAnyOfInner
 */
export interface RelevantUserFeedbackListAnyOfInner {
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check Function Call Results
         * @param {Array<string>} requestBody 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFunctionCallResultsCheckFunctionCallResultsGet: async (requestBody: Array<string>, timeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('checkFunctionCallResultsCheckFunctionCallResultsGet', 'requestBody', requestBody)
            const localVarPath = `/check_function_call_results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Soundbites Text
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSoundbitesTextDownloadSoundbitesTextGet: async (stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/download_soundbites_text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stepName !== undefined) {
                localVarQueryParameter['step_name'] = stepName;
            }

            if (substepName !== undefined) {
                localVarQueryParameter['substep_name'] = substepName;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Timeline
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTimelineDownloadTimelineGet: async (stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/download_timeline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stepName !== undefined) {
                localVarQueryParameter['step_name'] = stepName;
            }

            if (substepName !== undefined) {
                localVarQueryParameter['substep_name'] = substepName;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Transcript Text
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTranscriptTextDownloadTranscriptTextGet: async (stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/download_transcript_text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stepName !== undefined) {
                localVarQueryParameter['step_name'] = stepName;
            }

            if (substepName !== undefined) {
                localVarQueryParameter['substep_name'] = substepName;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Outputs
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOutputsGetAllOutputsGet: async (timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/get_all_outputs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Latest State
         * @param {boolean} [withOutput] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestStateGetLatestStateGet: async (withOutput?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/get_latest_state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withOutput !== undefined) {
                localVarQueryParameter['with_output'] = withOutput;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Video Processing Status
         * @param {string} userEmail 
         * @param {number} [timeout] 
         * @param {Array<string> | null} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoProcessingStatusGetVideoProcessingStatusGet: async (userEmail: string, timeout?: number, requestBody?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userEmail' is not null or undefined
            assertParamExists('getVideoProcessingStatusGetVideoProcessingStatusGet', 'userEmail', userEmail)
            const localVarPath = `/get_video_processing_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Workflow
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetWorkflowResetWorkflowGet: async (timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reset_workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revert Workflow Step
         * @param {boolean} [toBeforeRetries] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revertWorkflowStepRevertWorkflowStepGet: async (toBeforeRetries?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/revert_workflow_step`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (toBeforeRetries !== undefined) {
                localVarQueryParameter['to_before_retries'] = toBeforeRetries;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revert Workflow Step To
         * @param {string} stepName 
         * @param {string} substepName 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revertWorkflowStepToRevertWorkflowStepToGet: async (stepName: string, substepName: string, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stepName' is not null or undefined
            assertParamExists('revertWorkflowStepToRevertWorkflowStepToGet', 'stepName', stepName)
            // verify required parameter 'substepName' is not null or undefined
            assertParamExists('revertWorkflowStepToRevertWorkflowStepToGet', 'substepName', substepName)
            const localVarPath = `/revert_workflow_step_to`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stepName !== undefined) {
                localVarQueryParameter['step_name'] = stepName;
            }

            if (substepName !== undefined) {
                localVarQueryParameter['substep_name'] = substepName;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Step Endpoint
         * @param {string | null} [userInput] 
         * @param {boolean} [streaming] 
         * @param {boolean} [ignoreRunningWorkflows] 
         * @param {boolean} [retryStep] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepEndpointStepGet: async (userInput?: string | null, streaming?: boolean, ignoreRunningWorkflows?: boolean, retryStep?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/step`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userInput !== undefined) {
                localVarQueryParameter['user_input'] = userInput;
            }

            if (streaming !== undefined) {
                localVarQueryParameter['streaming'] = streaming;
            }

            if (ignoreRunningWorkflows !== undefined) {
                localVarQueryParameter['ignore_running_workflows'] = ignoreRunningWorkflows;
            }

            if (retryStep !== undefined) {
                localVarQueryParameter['retry_step'] = retryStep;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream Video
         * @param {string | null} [videoPath] 
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamVideoVideoGet: async (videoPath?: string | null, stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (videoPath !== undefined) {
                localVarQueryParameter['video_path'] = videoPath;
            }

            if (stepName !== undefined) {
                localVarQueryParameter['step_name'] = stepName;
            }

            if (substepName !== undefined) {
                localVarQueryParameter['substep_name'] = substepName;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Multiple Files
         * @param {Array<File>} files 
         * @param {Array<string>} highResUserFilePaths 
         * @param {string} timelineName 
         * @param {string} userEmail 
         * @param {boolean} [overwrite] 
         * @param {boolean} [useExistingOutput] 
         * @param {boolean} [reprocess] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipleFilesUploadPost: async (files: Array<File>, highResUserFilePaths: Array<string>, timelineName: string, userEmail: string, overwrite?: boolean, useExistingOutput?: boolean, reprocess?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadMultipleFilesUploadPost', 'files', files)
            // verify required parameter 'highResUserFilePaths' is not null or undefined
            assertParamExists('uploadMultipleFilesUploadPost', 'highResUserFilePaths', highResUserFilePaths)
            // verify required parameter 'timelineName' is not null or undefined
            assertParamExists('uploadMultipleFilesUploadPost', 'timelineName', timelineName)
            // verify required parameter 'userEmail' is not null or undefined
            assertParamExists('uploadMultipleFilesUploadPost', 'userEmail', userEmail)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (files) {
                files.forEach((element) => {
                  localVarFormParams.append('files', element as any);
                })
            }

                if (highResUserFilePaths) {
                localVarFormParams.append('high_res_user_file_paths', highResUserFilePaths.join(COLLECTION_FORMATS.csv));
            }

    
            if (timelineName !== undefined) { 
                localVarFormParams.append('timeline_name', timelineName as any);
            }
    
            if (overwrite !== undefined) { 
                localVarFormParams.append('overwrite', String(overwrite) as any);
            }
    
            if (useExistingOutput !== undefined) { 
                localVarFormParams.append('use_existing_output', String(useExistingOutput) as any);
            }
    
            if (reprocess !== undefined) { 
                localVarFormParams.append('reprocess', String(reprocess) as any);
            }
    
            if (userEmail !== undefined) { 
                localVarFormParams.append('user_email', userEmail as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploaded High Res Video Paths
         * @param {string} userEmail 
         * @param {Array<string>} [md5Hashes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedHighResVideoPathsUploadedHighResVideoPathsGet: async (userEmail: string, md5Hashes?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userEmail' is not null or undefined
            assertParamExists('uploadedHighResVideoPathsUploadedHighResVideoPathsGet', 'userEmail', userEmail)
            const localVarPath = `/uploaded_high_res_video_paths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (md5Hashes) {
                localVarQueryParameter['md5_hashes'] = md5Hashes;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploaded Video Hashes
         * @param {string} userEmail 
         * @param {Array<string>} [highResUserFilePaths] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedVideoHashesUploadedVideoHashesGet: async (userEmail: string, highResUserFilePaths?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userEmail' is not null or undefined
            assertParamExists('uploadedVideoHashesUploadedVideoHashesGet', 'userEmail', userEmail)
            const localVarPath = `/uploaded_video_hashes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (highResUserFilePaths) {
                localVarQueryParameter['high_res_user_file_paths'] = highResUserFilePaths;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploaded Videos
         * @param {string} userEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedVideosUploadedVideosGet: async (userEmail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userEmail' is not null or undefined
            assertParamExists('uploadedVideosUploadedVideosGet', 'userEmail', userEmail)
            const localVarPath = `/uploaded_videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check Function Call Results
         * @param {Array<string>} requestBody 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkFunctionCallResultsCheckFunctionCallResultsGet(requestBody: Array<string>, timeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkFunctionCallResultsCheckFunctionCallResultsGet(requestBody, timeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.checkFunctionCallResultsCheckFunctionCallResultsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Soundbites Text
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSoundbitesTextDownloadSoundbitesTextGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSoundbitesTextDownloadSoundbitesTextGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadSoundbitesTextDownloadSoundbitesTextGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Timeline
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTimelineDownloadTimelineGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTimelineDownloadTimelineGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadTimelineDownloadTimelineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Transcript Text
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTranscriptTextDownloadTranscriptTextGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTranscriptTextDownloadTranscriptTextGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadTranscriptTextDownloadTranscriptTextGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Outputs
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOutputsGetAllOutputsGet(timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOutputsGetAllOutputsGet(timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllOutputsGetAllOutputsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Latest State
         * @param {boolean} [withOutput] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestStateGetLatestStateGet(withOutput?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestStateGetLatestStateGet(withOutput, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLatestStateGetLatestStateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Video Processing Status
         * @param {string} userEmail 
         * @param {number} [timeout] 
         * @param {Array<string> | null} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoProcessingStatusGetVideoProcessingStatusGet(userEmail: string, timeout?: number, requestBody?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVideoProcessingStatusGetVideoProcessingStatusGet(userEmail, timeout, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getVideoProcessingStatusGetVideoProcessingStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset Workflow
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetWorkflowResetWorkflowGet(timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetWorkflowResetWorkflowGet(timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resetWorkflowResetWorkflowGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revert Workflow Step
         * @param {boolean} [toBeforeRetries] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revertWorkflowStepRevertWorkflowStepGet(toBeforeRetries?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revertWorkflowStepRevertWorkflowStepGet(toBeforeRetries, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.revertWorkflowStepRevertWorkflowStepGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revert Workflow Step To
         * @param {string} stepName 
         * @param {string} substepName 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revertWorkflowStepToRevertWorkflowStepToGet(stepName: string, substepName: string, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revertWorkflowStepToRevertWorkflowStepToGet(stepName, substepName, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.revertWorkflowStepToRevertWorkflowStepToGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Step Endpoint
         * @param {string | null} [userInput] 
         * @param {boolean} [streaming] 
         * @param {boolean} [ignoreRunningWorkflows] 
         * @param {boolean} [retryStep] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepEndpointStepGet(userInput?: string | null, streaming?: boolean, ignoreRunningWorkflows?: boolean, retryStep?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepEndpointStepGet(userInput, streaming, ignoreRunningWorkflows, retryStep, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.stepEndpointStepGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stream Video
         * @param {string | null} [videoPath] 
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamVideoVideoGet(videoPath?: string | null, stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamVideoVideoGet(videoPath, stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.streamVideoVideoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Multiple Files
         * @param {Array<File>} files 
         * @param {Array<string>} highResUserFilePaths 
         * @param {string} timelineName 
         * @param {string} userEmail 
         * @param {boolean} [overwrite] 
         * @param {boolean} [useExistingOutput] 
         * @param {boolean} [reprocess] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMultipleFilesUploadPost(files: Array<File>, highResUserFilePaths: Array<string>, timelineName: string, userEmail: string, overwrite?: boolean, useExistingOutput?: boolean, reprocess?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMultipleFilesUploadPost(files, highResUserFilePaths, timelineName, userEmail, overwrite, useExistingOutput, reprocess, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadMultipleFilesUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uploaded High Res Video Paths
         * @param {string} userEmail 
         * @param {Array<string>} [md5Hashes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedHighResVideoPathsUploadedHighResVideoPathsGet(userEmail: string, md5Hashes?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedHighResVideoPathsUploadedHighResVideoPathsGet(userEmail, md5Hashes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadedHighResVideoPathsUploadedHighResVideoPathsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uploaded Video Hashes
         * @param {string} userEmail 
         * @param {Array<string>} [highResUserFilePaths] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedVideoHashesUploadedVideoHashesGet(userEmail: string, highResUserFilePaths?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedVideoHashesUploadedVideoHashesGet(userEmail, highResUserFilePaths, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadedVideoHashesUploadedVideoHashesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uploaded Videos
         * @param {string} userEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedVideosUploadedVideosGet(userEmail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedVideosUploadedVideosGet(userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadedVideosUploadedVideosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Check Function Call Results
         * @param {Array<string>} requestBody 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFunctionCallResultsCheckFunctionCallResultsGet(requestBody: Array<string>, timeout?: number, options?: any): AxiosPromise<any> {
            return localVarFp.checkFunctionCallResultsCheckFunctionCallResultsGet(requestBody, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Soundbites Text
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSoundbitesTextDownloadSoundbitesTextGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.downloadSoundbitesTextDownloadSoundbitesTextGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Timeline
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTimelineDownloadTimelineGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.downloadTimelineDownloadTimelineGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Transcript Text
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTranscriptTextDownloadTranscriptTextGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.downloadTranscriptTextDownloadTranscriptTextGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Outputs
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOutputsGetAllOutputsGet(timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.getAllOutputsGetAllOutputsGet(timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Latest State
         * @param {boolean} [withOutput] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestStateGetLatestStateGet(withOutput?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.getLatestStateGetLatestStateGet(withOutput, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Video Processing Status
         * @param {string} userEmail 
         * @param {number} [timeout] 
         * @param {Array<string> | null} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoProcessingStatusGetVideoProcessingStatusGet(userEmail: string, timeout?: number, requestBody?: Array<string> | null, options?: any): AxiosPromise<any> {
            return localVarFp.getVideoProcessingStatusGetVideoProcessingStatusGet(userEmail, timeout, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Workflow
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetWorkflowResetWorkflowGet(timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.resetWorkflowResetWorkflowGet(timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revert Workflow Step
         * @param {boolean} [toBeforeRetries] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revertWorkflowStepRevertWorkflowStepGet(toBeforeRetries?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.revertWorkflowStepRevertWorkflowStepGet(toBeforeRetries, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revert Workflow Step To
         * @param {string} stepName 
         * @param {string} substepName 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revertWorkflowStepToRevertWorkflowStepToGet(stepName: string, substepName: string, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.revertWorkflowStepToRevertWorkflowStepToGet(stepName, substepName, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Step Endpoint
         * @param {string | null} [userInput] 
         * @param {boolean} [streaming] 
         * @param {boolean} [ignoreRunningWorkflows] 
         * @param {boolean} [retryStep] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepEndpointStepGet(userInput?: string | null, streaming?: boolean, ignoreRunningWorkflows?: boolean, retryStep?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.stepEndpointStepGet(userInput, streaming, ignoreRunningWorkflows, retryStep, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stream Video
         * @param {string | null} [videoPath] 
         * @param {string | null} [stepName] 
         * @param {string | null} [substepName] 
         * @param {boolean} [stream] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamVideoVideoGet(videoPath?: string | null, stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<any> {
            return localVarFp.streamVideoVideoGet(videoPath, stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Multiple Files
         * @param {Array<File>} files 
         * @param {Array<string>} highResUserFilePaths 
         * @param {string} timelineName 
         * @param {string} userEmail 
         * @param {boolean} [overwrite] 
         * @param {boolean} [useExistingOutput] 
         * @param {boolean} [reprocess] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipleFilesUploadPost(files: Array<File>, highResUserFilePaths: Array<string>, timelineName: string, userEmail: string, overwrite?: boolean, useExistingOutput?: boolean, reprocess?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.uploadMultipleFilesUploadPost(files, highResUserFilePaths, timelineName, userEmail, overwrite, useExistingOutput, reprocess, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploaded High Res Video Paths
         * @param {string} userEmail 
         * @param {Array<string>} [md5Hashes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedHighResVideoPathsUploadedHighResVideoPathsGet(userEmail: string, md5Hashes?: Array<string>, options?: any): AxiosPromise<any> {
            return localVarFp.uploadedHighResVideoPathsUploadedHighResVideoPathsGet(userEmail, md5Hashes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploaded Video Hashes
         * @param {string} userEmail 
         * @param {Array<string>} [highResUserFilePaths] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedVideoHashesUploadedVideoHashesGet(userEmail: string, highResUserFilePaths?: Array<string>, options?: any): AxiosPromise<any> {
            return localVarFp.uploadedVideoHashesUploadedVideoHashesGet(userEmail, highResUserFilePaths, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploaded Videos
         * @param {string} userEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedVideosUploadedVideosGet(userEmail: string, options?: any): AxiosPromise<any> {
            return localVarFp.uploadedVideosUploadedVideosGet(userEmail, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @summary Check Function Call Results
     * @param {Array<string>} requestBody 
     * @param {number} [timeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    checkFunctionCallResultsCheckFunctionCallResultsGet(requestBody: Array<string>, timeout?: number, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Download Soundbites Text
     * @param {string | null} [stepName] 
     * @param {string | null} [substepName] 
     * @param {boolean} [stream] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    downloadSoundbitesTextDownloadSoundbitesTextGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Download Timeline
     * @param {string | null} [stepName] 
     * @param {string | null} [substepName] 
     * @param {boolean} [stream] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    downloadTimelineDownloadTimelineGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Download Transcript Text
     * @param {string | null} [stepName] 
     * @param {string | null} [substepName] 
     * @param {boolean} [stream] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    downloadTranscriptTextDownloadTranscriptTextGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get All Outputs
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getAllOutputsGetAllOutputsGet(timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Latest State
     * @param {boolean} [withOutput] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getLatestStateGetLatestStateGet(withOutput?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Video Processing Status
     * @param {string} userEmail 
     * @param {number} [timeout] 
     * @param {Array<string> | null} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getVideoProcessingStatusGetVideoProcessingStatusGet(userEmail: string, timeout?: number, requestBody?: Array<string> | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Reset Workflow
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    resetWorkflowResetWorkflowGet(timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Revert Workflow Step
     * @param {boolean} [toBeforeRetries] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    revertWorkflowStepRevertWorkflowStepGet(toBeforeRetries?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Revert Workflow Step To
     * @param {string} stepName 
     * @param {string} substepName 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    revertWorkflowStepToRevertWorkflowStepToGet(stepName: string, substepName: string, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Step Endpoint
     * @param {string | null} [userInput] 
     * @param {boolean} [streaming] 
     * @param {boolean} [ignoreRunningWorkflows] 
     * @param {boolean} [retryStep] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    stepEndpointStepGet(userInput?: string | null, streaming?: boolean, ignoreRunningWorkflows?: boolean, retryStep?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Stream Video
     * @param {string | null} [videoPath] 
     * @param {string | null} [stepName] 
     * @param {string | null} [substepName] 
     * @param {boolean} [stream] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    streamVideoVideoGet(videoPath?: string | null, stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Upload Multiple Files
     * @param {Array<File>} files 
     * @param {Array<string>} highResUserFilePaths 
     * @param {string} timelineName 
     * @param {string} userEmail 
     * @param {boolean} [overwrite] 
     * @param {boolean} [useExistingOutput] 
     * @param {boolean} [reprocess] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    uploadMultipleFilesUploadPost(files: Array<File>, highResUserFilePaths: Array<string>, timelineName: string, userEmail: string, overwrite?: boolean, useExistingOutput?: boolean, reprocess?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Uploaded High Res Video Paths
     * @param {string} userEmail 
     * @param {Array<string>} [md5Hashes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    uploadedHighResVideoPathsUploadedHighResVideoPathsGet(userEmail: string, md5Hashes?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Uploaded Video Hashes
     * @param {string} userEmail 
     * @param {Array<string>} [highResUserFilePaths] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    uploadedVideoHashesUploadedVideoHashesGet(userEmail: string, highResUserFilePaths?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Uploaded Videos
     * @param {string} userEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    uploadedVideosUploadedVideosGet(userEmail: string, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @summary Check Function Call Results
     * @param {Array<string>} requestBody 
     * @param {number} [timeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public checkFunctionCallResultsCheckFunctionCallResultsGet(requestBody: Array<string>, timeout?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).checkFunctionCallResultsCheckFunctionCallResultsGet(requestBody, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Soundbites Text
     * @param {string | null} [stepName] 
     * @param {string | null} [substepName] 
     * @param {boolean} [stream] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadSoundbitesTextDownloadSoundbitesTextGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadSoundbitesTextDownloadSoundbitesTextGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Timeline
     * @param {string | null} [stepName] 
     * @param {string | null} [substepName] 
     * @param {boolean} [stream] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadTimelineDownloadTimelineGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadTimelineDownloadTimelineGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Transcript Text
     * @param {string | null} [stepName] 
     * @param {string | null} [substepName] 
     * @param {boolean} [stream] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadTranscriptTextDownloadTranscriptTextGet(stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadTranscriptTextDownloadTranscriptTextGet(stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Outputs
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllOutputsGetAllOutputsGet(timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllOutputsGetAllOutputsGet(timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Latest State
     * @param {boolean} [withOutput] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLatestStateGetLatestStateGet(withOutput?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLatestStateGetLatestStateGet(withOutput, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Video Processing Status
     * @param {string} userEmail 
     * @param {number} [timeout] 
     * @param {Array<string> | null} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVideoProcessingStatusGetVideoProcessingStatusGet(userEmail: string, timeout?: number, requestBody?: Array<string> | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVideoProcessingStatusGetVideoProcessingStatusGet(userEmail, timeout, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Workflow
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetWorkflowResetWorkflowGet(timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetWorkflowResetWorkflowGet(timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revert Workflow Step
     * @param {boolean} [toBeforeRetries] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public revertWorkflowStepRevertWorkflowStepGet(toBeforeRetries?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).revertWorkflowStepRevertWorkflowStepGet(toBeforeRetries, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revert Workflow Step To
     * @param {string} stepName 
     * @param {string} substepName 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public revertWorkflowStepToRevertWorkflowStepToGet(stepName: string, substepName: string, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).revertWorkflowStepToRevertWorkflowStepToGet(stepName, substepName, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Step Endpoint
     * @param {string | null} [userInput] 
     * @param {boolean} [streaming] 
     * @param {boolean} [ignoreRunningWorkflows] 
     * @param {boolean} [retryStep] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stepEndpointStepGet(userInput?: string | null, streaming?: boolean, ignoreRunningWorkflows?: boolean, retryStep?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stepEndpointStepGet(userInput, streaming, ignoreRunningWorkflows, retryStep, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stream Video
     * @param {string | null} [videoPath] 
     * @param {string | null} [stepName] 
     * @param {string | null} [substepName] 
     * @param {boolean} [stream] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public streamVideoVideoGet(videoPath?: string | null, stepName?: string | null, substepName?: string | null, stream?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).streamVideoVideoGet(videoPath, stepName, substepName, stream, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Multiple Files
     * @param {Array<File>} files 
     * @param {Array<string>} highResUserFilePaths 
     * @param {string} timelineName 
     * @param {string} userEmail 
     * @param {boolean} [overwrite] 
     * @param {boolean} [useExistingOutput] 
     * @param {boolean} [reprocess] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadMultipleFilesUploadPost(files: Array<File>, highResUserFilePaths: Array<string>, timelineName: string, userEmail: string, overwrite?: boolean, useExistingOutput?: boolean, reprocess?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadMultipleFilesUploadPost(files, highResUserFilePaths, timelineName, userEmail, overwrite, useExistingOutput, reprocess, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploaded High Res Video Paths
     * @param {string} userEmail 
     * @param {Array<string>} [md5Hashes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadedHighResVideoPathsUploadedHighResVideoPathsGet(userEmail: string, md5Hashes?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadedHighResVideoPathsUploadedHighResVideoPathsGet(userEmail, md5Hashes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploaded Video Hashes
     * @param {string} userEmail 
     * @param {Array<string>} [highResUserFilePaths] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadedVideoHashesUploadedVideoHashesGet(userEmail: string, highResUserFilePaths?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadedVideoHashesUploadedVideoHashesGet(userEmail, highResUserFilePaths, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploaded Videos
     * @param {string} userEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadedVideosUploadedVideosGet(userEmail: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadedVideosUploadedVideosGet(userEmail, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StepsApi - axios parameter creator
 * @export
 */
export const StepsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * TODO
         * @summary Get outputs for a given list of steps
         * @param {string} stepKeys 
         * @param {boolean} [latestRetry] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepOutputsGetStepOutputsGet: async (stepKeys: string, latestRetry?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stepKeys' is not null or undefined
            assertParamExists('getStepOutputsGetStepOutputsGet', 'stepKeys', stepKeys)
            const localVarPath = `/get_step_outputs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stepKeys !== undefined) {
                localVarQueryParameter['step_keys'] = stepKeys;
            }

            if (latestRetry !== undefined) {
                localVarQueryParameter['latest_retry'] = latestRetry;
            }

            if (timelineName !== undefined) {
                localVarQueryParameter['timeline_name'] = timelineName;
            }

            if (lengthSeconds !== undefined) {
                localVarQueryParameter['length_seconds'] = lengthSeconds;
            }

            if (videoHash !== undefined) {
                localVarQueryParameter['video_hash'] = videoHash;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['video_id'] = videoId;
            }

            if (waitUntilDoneRunning !== undefined) {
                localVarQueryParameter['wait_until_done_running'] = waitUntilDoneRunning;
            }

            if (blockUntil !== undefined) {
                localVarQueryParameter['block_until'] = blockUntil;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (waitInterval !== undefined) {
                localVarQueryParameter['wait_interval'] = waitInterval;
            }

            if (forceRestart !== undefined) {
                localVarQueryParameter['force_restart'] = forceRestart;
            }

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StepsApi - functional programming interface
 * @export
 */
export const StepsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StepsApiAxiosParamCreator(configuration)
    return {
        /**
         * TODO
         * @summary Get outputs for a given list of steps
         * @param {string} stepKeys 
         * @param {boolean} [latestRetry] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStepOutputsGetStepOutputsGet(stepKeys: string, latestRetry?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStepOutputs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStepOutputsGetStepOutputsGet(stepKeys, latestRetry, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepsApi.getStepOutputsGetStepOutputsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StepsApi - factory interface
 * @export
 */
export const StepsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StepsApiFp(configuration)
    return {
        /**
         * TODO
         * @summary Get outputs for a given list of steps
         * @param {string} stepKeys 
         * @param {boolean} [latestRetry] 
         * @param {string | null} [timelineName] 
         * @param {number | null} [lengthSeconds] 
         * @param {string | null} [videoHash] 
         * @param {string | null} [userId] 
         * @param {string | null} [videoId] 
         * @param {boolean} [waitUntilDoneRunning] 
         * @param {boolean} [blockUntil] 
         * @param {number} [timeout] 
         * @param {number} [waitInterval] 
         * @param {boolean} [forceRestart] 
         * @param {string | null} [userEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepOutputsGetStepOutputsGet(stepKeys: string, latestRetry?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: any): AxiosPromise<GetStepOutputs> {
            return localVarFp.getStepOutputsGetStepOutputsGet(stepKeys, latestRetry, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StepsApi - interface
 * @export
 * @interface StepsApi
 */
export interface StepsApiInterface {
    /**
     * TODO
     * @summary Get outputs for a given list of steps
     * @param {string} stepKeys 
     * @param {boolean} [latestRetry] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepsApiInterface
     */
    getStepOutputsGetStepOutputsGet(stepKeys: string, latestRetry?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<GetStepOutputs>;

}

/**
 * StepsApi - object-oriented interface
 * @export
 * @class StepsApi
 * @extends {BaseAPI}
 */
export class StepsApi extends BaseAPI implements StepsApiInterface {
    /**
     * TODO
     * @summary Get outputs for a given list of steps
     * @param {string} stepKeys 
     * @param {boolean} [latestRetry] 
     * @param {string | null} [timelineName] 
     * @param {number | null} [lengthSeconds] 
     * @param {string | null} [videoHash] 
     * @param {string | null} [userId] 
     * @param {string | null} [videoId] 
     * @param {boolean} [waitUntilDoneRunning] 
     * @param {boolean} [blockUntil] 
     * @param {number} [timeout] 
     * @param {number} [waitInterval] 
     * @param {boolean} [forceRestart] 
     * @param {string | null} [userEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepsApi
     */
    public getStepOutputsGetStepOutputsGet(stepKeys: string, latestRetry?: boolean, timelineName?: string | null, lengthSeconds?: number | null, videoHash?: string | null, userId?: string | null, videoId?: string | null, waitUntilDoneRunning?: boolean, blockUntil?: boolean, timeout?: number, waitInterval?: number, forceRestart?: boolean, userEmail?: string | null, options?: RawAxiosRequestConfig) {
        return StepsApiFp(this.configuration).getStepOutputsGetStepOutputsGet(stepKeys, latestRetry, timelineName, lengthSeconds, videoHash, userId, videoId, waitUntilDoneRunning, blockUntil, timeout, waitInterval, forceRestart, userEmail, options).then((request) => request(this.axios, this.basePath));
    }
}



